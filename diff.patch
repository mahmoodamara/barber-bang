diff --git a/src/controllers/auth.controller.js b/src/controllers/auth.controller.js
--- a/src/controllers/auth.controller.js
+++ b/src/controllers/auth.controller.js
@@ -1,25 +1,229 @@
-import { registerUser, loginUser } from "../services/auth.service.js";
 import { User } from "../models/User.js";
+import {
+  forgotPassword as forgotPasswordService,
+  loginUser,
+  logoutAllSessions,
+  logoutSession,
+  refreshSession,
+  registerUser,
+  resetPassword as resetPasswordService,
+} from "../services/auth.service.js";
+import {
+  clearRefreshCookie,
+  getRefreshTokenFromReq,
+  setRefreshCookie,
+} from "../utils/authTokens.js";
+import { logger } from "../utils/logger.js";
+
+function authError(statusCode, code) {
+  const err = new Error(code);
+  err.statusCode = statusCode;
+  err.code = code;
+  return err;
+}
+
+function normalizeEmailLower(value) {
+  return typeof value === "string" ? value.trim().toLowerCase() : "";
+}
+
+function getRequestMeta(req) {
+  return {
+    requestId: req.requestId,
+    ip: req.ip || null,
+    userAgent: req.get("user-agent") || "",
+  };
+}
+
+function audit(event, req, details = {}) {
+  const meta = getRequestMeta(req);
+  logger.info(
+    {
+      event,
+      requestId: meta.requestId,
+      userId: details.userId || null,
+      emailLower: details.emailLower || null,
+      ip: meta.ip,
+      userAgent: meta.userAgent,
+      outcome: details.outcome || "unknown",
+    },
+    `auth.${event}`,
+  );
+}
 
 export async function register(req, res) {
-  const { email, password, phone } = req.validated.body;
-  const user = await registerUser({ email, password, phone });
-
-  res.status(201).json({
-    ok: true,
-    user: { id: user.id, email: user.emailLower, roles: user.roles },
-  });
+  const body = req.validated?.body || req.body || {};
+  const emailLower = normalizeEmailLower(body.email);
+  try {
+    const user = await registerUser({
+      email: body.email,
+      password: body.password,
+      phone: body.phone,
+    });
+
+    audit("register", req, {
+      userId: user.id,
+      emailLower: user.emailLower || emailLower,
+      outcome: "success",
+    });
+
+    res.status(201).json({
+      ok: true,
+      user: { id: user.id, email: user.emailLower, roles: user.roles },
+    });
+  } catch (err) {
+    audit("register", req, { emailLower, outcome: "failed" });
+    throw err;
+  }
 }
 
 export async function login(req, res) {
-  const { email, password } = req.validated.body;
-  const { user, token } = await loginUser({ email, password });
-
-  res.json({
-    ok: true,
-    token,
-    user: { id: user.id, email: user.emailLower, roles: user.roles },
-  });
+  const body = req.validated?.body || req.body || {};
+  const emailLower = normalizeEmailLower(body.email);
+  const meta = getRequestMeta(req);
+
+  try {
+    const { user, token, refreshToken, refreshTtlMs } = await loginUser({
+      email: body.email,
+      password: body.password,
+      ip: meta.ip,
+      userAgent: meta.userAgent,
+    });
+
+    setRefreshCookie(res, refreshToken, refreshTtlMs);
+
+    audit("login_success", req, {
+      userId: user.id,
+      emailLower: user.emailLower || emailLower,
+      outcome: "success",
+    });
+
+    res.json({
+      ok: true,
+      token,
+      user: { id: user.id, email: user.emailLower, roles: user.roles },
+    });
+  } catch (err) {
+    audit("login_failed", req, { emailLower, outcome: "failed" });
+    throw err;
+  }
+}
+
+export async function refresh(req, res) {
+  const refreshToken = getRefreshTokenFromReq(req);
+  if (!refreshToken) {
+    audit("refresh", req, { outcome: "failed" });
+    throw authError(401, "AUTH_REQUIRED");
+  }
+
+  const meta = getRequestMeta(req);
+  try {
+    const { user, token, refreshToken: nextToken, refreshTtlMs } = await refreshSession({
+      refreshToken,
+      ip: meta.ip,
+      userAgent: meta.userAgent,
+    });
+
+    setRefreshCookie(res, nextToken, refreshTtlMs);
+
+    audit("refresh", req, {
+      userId: user.id,
+      emailLower: user.emailLower,
+      outcome: "success",
+    });
+
+    res.json({
+      ok: true,
+      token,
+      user: { id: user.id, email: user.emailLower, roles: user.roles },
+    });
+  } catch (err) {
+    clearRefreshCookie(res);
+    audit("refresh", req, { outcome: "failed" });
+    throw err;
+  }
+}
+
+export async function logout(req, res) {
+  const refreshToken = getRefreshTokenFromReq(req);
+  try {
+    const result = await logoutSession({ refreshToken });
+    clearRefreshCookie(res);
+
+    audit("logout", req, {
+      userId: result.userId ? String(result.userId) : null,
+      outcome: "success",
+    });
+
+    res.json({ ok: true });
+  } catch (err) {
+    clearRefreshCookie(res);
+    audit("logout", req, { outcome: "failed" });
+    throw err;
+  }
+}
+
+export async function logoutAll(req, res) {
+  const userId = req.auth?.userId;
+  const emailLower = req.auth?.email ? normalizeEmailLower(req.auth.email) : null;
+
+  try {
+    const user = await logoutAllSessions({ userId });
+    clearRefreshCookie(res);
+
+    audit("logout_all", req, {
+      userId: user.id,
+      emailLower: user.emailLower || emailLower,
+      outcome: "success",
+    });
+
+    res.json({ ok: true });
+  } catch (err) {
+    clearRefreshCookie(res);
+    audit("logout_all", req, { userId, emailLower, outcome: "failed" });
+    throw err;
+  }
+}
+
+export async function forgotPassword(req, res) {
+  const body = req.validated?.body || req.body || {};
+  const emailLower = normalizeEmailLower(body.email);
+  const meta = getRequestMeta(req);
+
+  try {
+    await forgotPasswordService({
+      email: body.email,
+      ip: meta.ip,
+      userAgent: meta.userAgent,
+    });
+
+    audit("forgot_password", req, { emailLower, outcome: "success" });
+    res.json({ ok: true });
+  } catch (err) {
+    audit("forgot_password", req, { emailLower, outcome: "failed" });
+    throw err;
+  }
+}
+
+export async function resetPassword(req, res) {
+  const body = req.validated?.body || req.body || {};
+
+  try {
+    const { user } = await resetPasswordService({
+      token: body.token,
+      password: body.password,
+    });
+
+    audit("reset_password", req, {
+      userId: user?.id || null,
+      emailLower: user?.emailLower || null,
+      outcome: "success",
+    });
+
+    res.json({ ok: true });
+  } catch (err) {
+    audit("reset_password", req, { outcome: "failed" });
+    throw err;
+  }
 }
 
 export async function me(req, res) {
diff --git a/src/services/auth.service.js b/src/services/auth.service.js
--- a/src/services/auth.service.js
+++ b/src/services/auth.service.js
@@ -1,7 +1,16 @@
 import bcrypt from "bcryptjs";
-import jwt from "jsonwebtoken";
-import { ENV } from "../utils/env.js";
 import { User } from "../models/User.js";
+import { RefreshSession } from "../models/RefreshSession.js";
+import { PasswordResetToken } from "../models/PasswordResetToken.js";
+import { sendPasswordResetEmail } from "./mail.service.js";
+import {
+  generateToken,
+  getPasswordResetTtlMs,
+  getRefreshTokenTtlMs,
+  hashToken,
+  safeEqual,
+  signAccessToken,
+} from "../utils/authTokens.js";
 
 const LOCKOUT_POLICY = [
   { threshold: 5, lockMs: 5 * 60_000 },
@@ -9,6 +18,8 @@
   { threshold: 10, lockMs: 60 * 60_000 },
 ];
 
+const DUMMY_PASSWORD_HASH = "$2a$12$ZVtf8ROJP.ghw9X4Jd7ryewKw9s2EfqpVt5cj0rnF2QDX/FRVA86m";
+
 function lockoutMs(failedCount) {
   let ms = 0;
   for (const step of LOCKOUT_POLICY) {
@@ -17,52 +28,83 @@
   return ms;
 }
 
-function recordFailedLogin(user, now) {
-  const nextCount = Number(user.failedLoginCount || 0) + 1;
-  user.failedLoginCount = nextCount;
-  user.lastFailedLoginAt = now;
-
-  const lockMs = lockoutMs(nextCount);
-  if (lockMs) user.lockUntil = new Date(Date.now() + lockMs);
-  return lockMs;
+function authError(statusCode, code) {
+  const err = new Error(code);
+  err.statusCode = statusCode;
+  err.code = code;
+  return err;
+}
+
+function normalizeEmail(email) {
+  const rawEmail = String(email || "").trim();
+  return { rawEmail, emailLower: rawEmail ? rawEmail.toLowerCase() : "" };
+}
+
+function normalizeMeta({ ip, userAgent } = {}) {
+  const cleanIp = typeof ip === "string" ? ip.trim().slice(0, 64) : "";
+  const cleanUa = typeof userAgent === "string" ? userAgent.trim().slice(0, 200) : "";
+  return {
+    ip: cleanIp || null,
+    userAgent: cleanUa || null,
+  };
+}
+
+async function createRefreshSession({ userId, ip, userAgent }) {
+  const ttlMs = getRefreshTokenTtlMs();
+  const expiresAt = new Date(Date.now() + ttlMs);
+  const meta = normalizeMeta({ ip, userAgent });
+
+  for (let attempt = 0; attempt < 2; attempt += 1) {
+    const refreshToken = generateToken();
+    const tokenHash = hashToken(refreshToken);
+    try {
+      await RefreshSession.create({
+        userId,
+        tokenHash,
+        createdAt: new Date(),
+        expiresAt,
+        ip: meta.ip,
+        userAgent: meta.userAgent,
+      });
+      return { refreshToken, refreshTtlMs: ttlMs };
+    } catch (err) {
+      if (err?.code === 11000 && attempt === 0) continue;
+      throw err;
+    }
+  }
+  throw new Error("REFRESH_SESSION_CREATE_FAILED");
 }
 
 export async function registerUser({ email, password, phone }) {
-  const rawEmail = String(email || "").trim();
-  if (!rawEmail) {
-    const err = new Error("EMAIL_REQUIRED");
-    err.statusCode = 400;
-    throw err;
-  }
-  const emailLower = rawEmail.toLowerCase();
+  const { rawEmail, emailLower } = normalizeEmail(email);
+  if (!rawEmail) throw authError(400, "EMAIL_REQUIRED");
 
   const exists = await User.findOne({ emailLower }).lean();
-  if (exists) {
-    const err = new Error("EMAIL_ALREADY_EXISTS");
-    err.statusCode = 409;
-    throw err;
-  }
-
-  const passwordHash = await bcrypt.hash(password, 12);
-
-  let user;
+  if (exists) throw authError(409, "EMAIL_ALREADY_EXISTS");
+
+  const safePhone = typeof phone === "string" ? phone.trim() : undefined;
+
+  const user = new User({
+    email: rawEmail,
+    emailLower,
+    phone: safePhone || undefined,
+    roles: ["user"],
+    isActive: true,
+  });
+
+  await user.setPassword(password);
+
   try {
-    user = await User.create({
-      email: rawEmail,
-      emailLower,
-      phone,
-      passwordHash,
-      roles: ["user"],
-      isActive: true,
-    });
+    await user.save();
   } catch (err) {
-    // Handle race-condition duplicate key errors (email/phone unique indexes).
     if (err?.code === 11000) {
       const key = err?.keyPattern || err?.keyValue || {};
-      const code = key.emailLower ? "EMAIL_ALREADY_EXISTS" : key.phone ? "PHONE_ALREADY_EXISTS" : "DUPLICATE_KEY";
-      const e = new Error(code);
-      e.statusCode = 409;
-      throw e;
+      const code = key.emailLower
+        ? "EMAIL_ALREADY_EXISTS"
+        : key.phone
+          ? "PHONE_ALREADY_EXISTS"
+          : "DUPLICATE_KEY";
+      throw authError(409, code);
     }
     throw err;
   }
@@ -70,69 +112,201 @@
   return user;
 }
 
-export async function loginUser({ email, password }) {
-  const emailLower = String(email).trim().toLowerCase();
-  // passwordHash is select:false by default
+export async function loginUser({ email, password, ip, userAgent }) {
+  const { emailLower } = normalizeEmail(email);
+
   const user = await User.findOne({ emailLower }).select(
-    "+passwordHash roles isActive tokenVersion failedLoginCount lockUntil lastFailedLoginAt emailLower",
+    "+passwordHash roles isActive tokenVersion failedLoginCount loginAttempts lockUntil lastFailedLoginAt emailLower",
   );
 
   if (!user || !user.isActive) {
-    const err = new Error("INVALID_CREDENTIALS");
-    err.statusCode = 401;
-    throw err;
+    await bcrypt.compare(String(password || ""), DUMMY_PASSWORD_HASH);
+    throw authError(401, "INVALID_CREDENTIALS");
   }
 
   const now = new Date();
-  if (user.lockUntil && user.lockUntil > now) {
-    const err = new Error("ACCOUNT_LOCKED");
-    err.statusCode = 429;
-    throw err;
+
+  if (user.isLocked && user.isLocked(now)) {
+    throw authError(429, "ACCOUNT_LOCKED");
   }
 
   if (user.lockUntil && user.lockUntil <= now) {
+    if (user.resetLoginAttempts) user.resetLoginAttempts();
+  }
+
+  const ok = await user.verifyPassword(password);
+  if (!ok) {
+    const current = Math.max(Number(user.loginAttempts || 0), Number(user.failedLoginCount || 0));
+    const nextCount = current + 1;
+    const lockMs = lockoutMs(nextCount);
+    if (user.incLoginAttempts) {
+      user.incLoginAttempts({ lockMs, now, nextCount });
+    } else {
+      user.failedLoginCount = nextCount;
+      user.loginAttempts = nextCount;
+      user.lastFailedLoginAt = now;
+      if (lockMs) user.lockUntil = new Date(now.getTime() + lockMs);
+    }
+    await user.save();
+    if (lockMs) throw authError(429, "ACCOUNT_LOCKED");
+    throw authError(401, "INVALID_CREDENTIALS");
+  }
+
+  user.lastLoginAt = now;
+  if (user.resetLoginAttempts) {
+    user.resetLoginAttempts();
+  } else {
+    user.failedLoginCount = 0;
+    user.loginAttempts = 0;
     user.lockUntil = null;
-    user.failedLoginCount = 0;
     user.lastFailedLoginAt = null;
   }
-
-  const ok = await bcrypt.compare(password, user.passwordHash || "");
-  if (!ok) {
-    const lockMs = recordFailedLogin(user, now);
-    await user.save();
-    if (lockMs) {
-      const err = new Error("ACCOUNT_LOCKED");
-      err.statusCode = 429;
-      throw err;
-    }
-    const err = new Error("INVALID_CREDENTIALS");
-    err.statusCode = 401;
-    throw err;
-  }
-
-  user.lastLoginAt = now;
-  user.failedLoginCount = 0;
-  user.lockUntil = null;
-  user.lastFailedLoginAt = null;
   await user.save();
 
-  // Never expose password hash
+  const token = signAccessToken({
+    userId: user._id.toString(),
+    roles: user.roles,
+    emailLower: user.emailLower,
+    tokenVersion: user.tokenVersion || 0,
+  });
+
+  const session = await createRefreshSession({ userId: user._id, ip, userAgent });
   user.passwordHash = undefined;
 
-  // never leak the hash in the response
-  user.passwordHash = undefined;
-
-  const token = jwt.sign(
-    { roles: user.roles, email: user.emailLower, tv: user.tokenVersion || 0 },
-    ENV.JWT_SECRET,
-    {
-      subject: user._id.toString(),
-      issuer: ENV.JWT_ISSUER,
-      audience: ENV.JWT_AUDIENCE,
-      expiresIn: ENV.ACCESS_TOKEN_TTL || "15m",
-      algorithm: "HS256",
-    },
+  return { user, token, refreshToken: session.refreshToken, refreshTtlMs: session.refreshTtlMs };
+}
+
+export async function refreshSession({ refreshToken, ip, userAgent }) {
+  if (!refreshToken) throw authError(401, "AUTH_REQUIRED");
+  const tokenHash = hashToken(refreshToken);
+  const session = await RefreshSession.findOne({ tokenHash });
+
+  if (!session || !safeEqual(session.tokenHash, tokenHash)) {
+    throw authError(401, "AUTH_INVALID");
+  }
+
+  const now = new Date();
+  if (session.revokedAt || session.rotatedAt) throw authError(401, "AUTH_INVALID");
+  if (session.expiresAt && session.expiresAt <= now) {
+    if (!session.revokedAt) {
+      session.revokedAt = now;
+      await session.save();
+    }
+    throw authError(401, "AUTH_INVALID");
+  }
+
+  session.rotatedAt = now;
+  session.revokedAt = now;
+  await session.save();
+
+  const user = await User.findById(session.userId).select("roles isActive tokenVersion emailLower");
+  if (!user || !user.isActive) throw authError(401, "AUTH_INVALID");
+
+  const token = signAccessToken({
+    userId: user._id.toString(),
+    roles: user.roles,
+    emailLower: user.emailLower,
+    tokenVersion: user.tokenVersion || 0,
+  });
+
+  const nextSession = await createRefreshSession({ userId: user._id, ip, userAgent });
+  return {
+    user,
+    token,
+    refreshToken: nextSession.refreshToken,
+    refreshTtlMs: nextSession.refreshTtlMs,
+  };
+}
+
+export async function logoutSession({ refreshToken }) {
+  if (!refreshToken) return { revoked: false };
+  const tokenHash = hashToken(refreshToken);
+  const session = await RefreshSession.findOne({ tokenHash });
+  if (!session || !safeEqual(session.tokenHash, tokenHash)) return { revoked: false };
+
+  if (!session.revokedAt) {
+    session.revokedAt = new Date();
+    await session.save();
+  }
+
+  return { revoked: true, userId: session.userId };
+}
+
+export async function logoutAllSessions({ userId }) {
+  if (!userId) throw authError(401, "AUTH_REQUIRED");
+  const user = await User.findById(userId).select("tokenVersion emailLower roles isActive");
+  if (!user || !user.isActive) throw authError(401, "AUTH_INVALID");
+
+  user.tokenVersion = Number(user.tokenVersion || 0) + 1;
+  await user.save();
+
+  const now = new Date();
+  await RefreshSession.updateMany({ userId: user._id }, { $set: { revokedAt: now } });
+
+  return user;
+}
+
+export async function forgotPassword({ email, ip, userAgent }) {
+  const { emailLower } = normalizeEmail(email);
+  if (!emailLower) return { ok: true };
+
+  const user = await User.findOne({ emailLower }).select("emailLower isActive").lean();
+  if (!user || !user.isActive) return { ok: true };
+
+  const ttlMs = getPasswordResetTtlMs();
+  const expiresAt = new Date(Date.now() + ttlMs);
+  const meta = normalizeMeta({ ip, userAgent });
+
+  await PasswordResetToken.deleteMany({ userId: user._id });
+
+  const rawToken = generateToken();
+  const tokenHash = hashToken(rawToken);
+  await PasswordResetToken.create({
+    userId: user._id,
+    tokenHash,
+    createdAt: new Date(),
+    expiresAt,
+    ip: meta.ip,
+    userAgent: meta.userAgent,
+  });
+
+  try {
+    await sendPasswordResetEmail({ to: user.emailLower, token: rawToken });
+  } catch {
+    return { ok: true };
+  }
+
+  return { ok: true };
+}
+
+export async function resetPassword({ token, password }) {
+  const tokenHash = hashToken(token);
+  const reset = await PasswordResetToken.findOne({ tokenHash });
+  if (!reset || !safeEqual(reset.tokenHash, tokenHash)) throw authError(400, "RESET_TOKEN_INVALID");
+
+  const now = new Date();
+  if (reset.usedAt || (reset.expiresAt && reset.expiresAt <= now)) {
+    if (!reset.usedAt) {
+      reset.usedAt = now;
+      await reset.save();
+    }
+    throw authError(400, "RESET_TOKEN_INVALID");
+  }
+
+  const user = await User.findById(reset.userId).select(
+    "+passwordHash tokenVersion isActive emailLower roles",
   );
-
-  return { user, token };
-}
+  if (!user || !user.isActive) throw authError(400, "RESET_TOKEN_INVALID");
+
+  await user.setPassword(password);
+  user.tokenVersion = Number(user.tokenVersion || 0) + 1;
+  if (user.resetLoginAttempts) user.resetLoginAttempts();
+  await user.save();
+
+  reset.usedAt = now;
+  await reset.save();
+
+  await RefreshSession.updateMany({ userId: user._id }, { $set: { revokedAt: now } });
+
+  return { user };
+}
diff --git a/src/models/User.js b/src/models/User.js
--- a/src/models/User.js
+++ b/src/models/User.js
@@ -1,8 +1,14 @@
 // src/models/User.js
+import bcrypt from "bcryptjs";
 import mongoose from "mongoose";
 import { baseToJSON, getOrCreateModel } from "./_helpers.js";
 
 const { Schema } = mongoose;
+
+const BCRYPT_ROUNDS = (() => {
+  const raw = Number(process.env.BCRYPT_COST || 12);
+  return Number.isFinite(raw) && raw >= 12 ? raw : 12;
+})();
 
 function trimOrUndef(v) {
   if (v === null || v === undefined) return undefined;
@@ -47,10 +53,10 @@
 const UserSchema = new Schema(
   {
     email: { type: String, trim: true, maxlength: 254, default: undefined },
-    emailLower: { type: String, trim: true, maxlength: 254, default: undefined }, // normalized
+    emailLower: { type: String, trim: true, lowercase: true, maxlength: 254, default: undefined }, // normalized
     phone: { type: String, trim: true, maxlength: 30, default: undefined },
 
-    // IMPORTANT: لا نُرجع الهاش بالـ queries افتراضيًا
+    // IMPORTANT: keep passwordHash select:false to avoid leaking in queries.
     passwordHash: { type: String, trim: true, minlength: 20, select: false },
 
     roles: { type: [String], default: ["user"], index: true }, // user/staff/admin
@@ -58,6 +64,7 @@
     tokenVersion: { type: Number, default: 0 },
 
     failedLoginCount: { type: Number, default: 0 },
+    loginAttempts: { type: Number, default: 0 },
     lockUntil: { type: Date, default: null },
     lastFailedLoginAt: { type: Date, default: null },
 
@@ -135,6 +142,44 @@
   next();
 });
 
+UserSchema.methods.setPassword = async function setPassword(password) {
+  const raw = String(password || "");
+  this.passwordHash = await bcrypt.hash(raw, BCRYPT_ROUNDS);
+};
+
+UserSchema.methods.verifyPassword = async function verifyPassword(password) {
+  if (!this.passwordHash) return false;
+  return bcrypt.compare(String(password || ""), this.passwordHash);
+};
+
+UserSchema.methods.isLocked = function isLocked(now = new Date()) {
+  if (!this.lockUntil) return false;
+  const ts = now instanceof Date ? now.getTime() : Number(now) || Date.now();
+  return this.lockUntil.getTime() > ts;
+};
+
+UserSchema.methods.incLoginAttempts = function incLoginAttempts({
+  lockMs = 0,
+  now = new Date(),
+  nextCount,
+} = {}) {
+  const current = Math.max(Number(this.loginAttempts || 0), Number(this.failedLoginCount || 0));
+  const count = Number.isFinite(nextCount) ? nextCount : current + 1;
+  const when = now instanceof Date ? now : new Date(now);
+  this.loginAttempts = count;
+  this.failedLoginCount = count;
+  this.lastFailedLoginAt = when;
+  if (lockMs) this.lockUntil = new Date(when.getTime() + lockMs);
+  return count;
+};
+
+UserSchema.methods.resetLoginAttempts = function resetLoginAttempts() {
+  this.loginAttempts = 0;
+  this.failedLoginCount = 0;
+  this.lockUntil = null;
+  this.lastFailedLoginAt = null;
+};
+
 baseToJSON(UserSchema);
 
 export const User = getOrCreateModel("User", UserSchema);
diff --git a/src/middlewares/auth.js b/src/middlewares/auth.js
--- a/src/middlewares/auth.js
+++ b/src/middlewares/auth.js
@@ -1,6 +1,7 @@
-import jwt from "jsonwebtoken";
 import { ENV } from "../utils/env.js";
 import { User } from "../models/User.js";
+import { verifyAccessToken } from "../utils/authTokens.js";
+// REQUIRED: update auth middleware for token version + secret rotation validation.
 
 const AUTH_CACHE_TTL_MS = (() => {
   const raw = Number(ENV.AUTH_CACHE_TTL_MS || 60_000);
@@ -55,14 +56,22 @@
   }
 
   try {
-    const payload = jwt.verify(token, ENV.JWT_SECRET, {
-      issuer: ENV.JWT_ISSUER,
-      audience: ENV.JWT_AUDIENCE,
-      algorithms: ["HS256"],
-    });
+    const payload = verifyAccessToken(token);
+    if (!payload || typeof payload !== "object") {
+      const err = new Error("AUTH_INVALID");
+      err.statusCode = 401;
+      return next(err);
+    }
 
-    const tokenVersion = Number(payload.tv || 0);
-    const cached = getCachedAuth(payload.sub);
+    const userId = String(payload.sub || "");
+    if (!userId) {
+      const err = new Error("AUTH_INVALID");
+      err.statusCode = 401;
+      return next(err);
+    }
+
+    const tokenVersion = Number(payload.tokenVersion ?? payload.tv ?? 0);
+    const cached = getCachedAuth(userId);
     if (cached) {
       if (cached.isActive === false) {
         const err = new Error("AUTH_INVALID");
@@ -72,7 +81,7 @@
       const cachedVersion = Number(cached.tokenVersion || 0);
       if (tokenVersion === cachedVersion) {
         req.auth = {
-          userId: payload.sub,
+          userId,
           roles: cached.roles || ["user"],
           email: cached.emailLower || payload.email,
         };
@@ -85,13 +94,13 @@
       }
     }
 
-    const user = await User.findById(payload.sub)
+    const user = await User.findById(userId)
       .select("roles isActive tokenVersion emailLower")
       .lean();
 
     if (!user || !user.isActive) {
       if (user) {
-        setCachedAuth(payload.sub, {
+        setCachedAuth(userId, {
           roles: user.roles || ["user"],
           isActive: false,
           tokenVersion: user.tokenVersion || 0,
@@ -105,7 +114,7 @@
 
     const userVersion = Number(user.tokenVersion || 0);
     if (tokenVersion !== userVersion) {
-      setCachedAuth(payload.sub, {
+      setCachedAuth(userId, {
         roles: user.roles || ["user"],
         isActive: user.isActive,
         tokenVersion: userVersion,
@@ -116,7 +125,7 @@
       return next(err);
     }
 
-    setCachedAuth(payload.sub, {
+    setCachedAuth(userId, {
       roles: user.roles || ["user"],
       isActive: user.isActive,
       tokenVersion: user.tokenVersion || 0,
@@ -124,7 +133,7 @@
     });
 
     req.auth = {
-      userId: payload.sub,
+      userId,
       roles: user.roles || ["user"],
       email: user.emailLower || payload.email,
     };
diff --git a/src/api/routes/auth.routes.js b/src/api/routes/auth.routes.js
--- a/src/api/routes/auth.routes.js
+++ b/src/api/routes/auth.routes.js
@@ -1,15 +1,39 @@
 import { Router } from "express";
 import { asyncHandler } from "../../middlewares/asyncHandler.js";
 import { validate } from "../../middlewares/validate.js";
-import { authLimiter } from "../../middlewares/authLimiter.js";
-import { registerSchema, loginSchema } from "../../validators/auth.validators.js";
-import { register, login, me } from "../../controllers/auth.controller.js";
+// REQUIRED: expose new auth endpoints for security upgrade.
+import {
+  authForgotPasswordLimiter,
+  authLoginLimiter,
+  authRegisterLimiter,
+} from "../../middlewares/rateLimit.js";
+import { authSchemas } from "../../utils/authSchemas.js";
+import {
+  forgotPassword,
+  login,
+  logout,
+  logoutAll,
+  me,
+  refresh,
+  register,
+  resetPassword,
+} from "../../controllers/auth.controller.js";
 import { requireAuth } from "../../middlewares/auth.js";
 
 const router = Router();
 
-router.post("/register", authLimiter, validate(registerSchema), asyncHandler(register));
-router.post("/login", authLimiter, validate(loginSchema), asyncHandler(login));
+router.post("/register", authRegisterLimiter, validate(authSchemas.register), asyncHandler(register));
+router.post("/login", authLoginLimiter, validate(authSchemas.login), asyncHandler(login));
+router.post("/refresh", validate(authSchemas.refresh), asyncHandler(refresh));
+router.post("/logout", validate(authSchemas.logout), asyncHandler(logout));
+router.post("/logout-all", requireAuth, validate(authSchemas.logoutAll), asyncHandler(logoutAll));
+router.post(
+  "/forgot-password",
+  authForgotPasswordLimiter,
+  validate(authSchemas.forgotPassword),
+  asyncHandler(forgotPassword),
+);
+router.post("/reset-password", validate(authSchemas.resetPassword), asyncHandler(resetPassword));
 router.get("/me", requireAuth, asyncHandler(me));
 
 export default router;
diff --git a/src/middlewares/rateLimit.js b/src/middlewares/rateLimit.js
new file mode 100644
--- /dev/null
+++ b/src/middlewares/rateLimit.js
@@ -0,0 +1,243 @@
+import net from "node:net";
+import tls from "node:tls";
+import { ENV } from "../utils/env.js";
+import { logger } from "../utils/logger.js";
+
+const RATE_LIMIT_WINDOW_MS = toPositiveInt(ENV.AUTH_LIMIT_WINDOW_MS, 15 * 60_000);
+const RATE_LIMIT_MAX = toPositiveInt(ENV.AUTH_LIMIT_MAX, 20);
+const REDIS_URL = process.env.REDIS_URL;
+
+function toPositiveInt(value, fallback) {
+  const n = Number(value);
+  return Number.isFinite(n) && n > 0 ? n : fallback;
+}
+
+function getIp(req) {
+  const direct = req.ip;
+  if (direct) return direct;
+  const forwarded = req.headers["x-forwarded-for"];
+  if (!forwarded) return "ip";
+  return String(forwarded).split(",")[0]?.trim() || "ip";
+}
+
+function getEmailLower(req) {
+  const body = req.body && typeof req.body === "object" ? req.body : {};
+  const email = typeof body.email === "string" ? body.email.trim().toLowerCase() : "";
+  return email;
+}
+
+function makeKey(req, includeEmail) {
+  const ip = getIp(req);
+  if (!includeEmail) return ip;
+  const email = getEmailLower(req);
+  return email ? `${ip}::${email}` : ip;
+}
+
+function encodeCommand(args) {
+  let out = `*${args.length}\r\n`;
+  for (const arg of args) {
+    const str = String(arg);
+    out += `$${Buffer.byteLength(str)}\r\n${str}\r\n`;
+  }
+  return out;
+}
+
+function parseLine(buffer, start) {
+  const end = buffer.indexOf("\r\n", start);
+  if (end === -1) return null;
+  const line = buffer.slice(start, end).toString();
+  return { line, next: end + 2 };
+}
+
+function parseResp(buffer, start = 0) {
+  if (start >= buffer.length) return null;
+  const type = buffer[start];
+  if (type === 43 || type === 45 || type === 58) {
+    const line = parseLine(buffer, start + 1);
+    if (!line) return null;
+    if (type === 58) return { value: Number(line.line), offset: line.next };
+    if (type === 45) {
+      const err = new Error(line.line);
+      err.name = "RedisError";
+      return { value: err, offset: line.next };
+    }
+    return { value: line.line, offset: line.next };
+  }
+  if (type === 36) {
+    const line = parseLine(buffer, start + 1);
+    if (!line) return null;
+    const len = Number(line.line);
+    if (len === -1) return { value: null, offset: line.next };
+    const end = line.next + len;
+    if (buffer.length < end + 2) return null;
+    const value = buffer.slice(line.next, end).toString();
+    return { value, offset: end + 2 };
+  }
+  if (type === 42) {
+    const line = parseLine(buffer, start + 1);
+    if (!line) return null;
+    const count = Number(line.line);
+    if (count === -1) return { value: null, offset: line.next };
+    const items = [];
+    let offset = line.next;
+    for (let i = 0; i < count; i += 1) {
+      const parsed = parseResp(buffer, offset);
+      if (!parsed) return null;
+      items.push(parsed.value);
+      offset = parsed.offset;
+    }
+    return { value: items, offset };
+  }
+  return null;
+}
+
+function parseRedisUrl(url) {
+  const parsed = new URL(url);
+  const host = parsed.hostname;
+  const port = Number(parsed.port || 6379);
+  const useTls = parsed.protocol === "rediss:";
+  const username = parsed.username ? decodeURIComponent(parsed.username) : null;
+  const password = parsed.password ? decodeURIComponent(parsed.password) : null;
+  const db = parsed.pathname ? Number(parsed.pathname.replace("/", "")) : 0;
+  return { host, port, useTls, username, password, db: Number.isFinite(db) ? db : 0 };
+}
+
+async function sendRedisCommands(config, commands) {
+  const payload = commands.map(encodeCommand).join("");
+  return new Promise((resolve, reject) => {
+    const socket = config.useTls
+      ? tls.connect({ host: config.host, port: config.port, servername: config.host })
+      : net.createConnection({ host: config.host, port: config.port });
+    const expected = commands.length;
+    let buffer = Buffer.alloc(0);
+    const responses = [];
+
+    const cleanup = () => {
+      socket.removeAllListeners("data");
+      socket.removeAllListeners("error");
+      socket.removeAllListeners("timeout");
+    };
+
+    socket.setTimeout(5000);
+    socket.on("error", (err) => {
+      cleanup();
+      socket.destroy();
+      reject(err);
+    });
+    socket.on("timeout", () => {
+      cleanup();
+      socket.destroy();
+      reject(new Error("REDIS_TIMEOUT"));
+    });
+    socket.on("data", (chunk) => {
+      buffer = Buffer.concat([buffer, chunk]);
+      while (responses.length < expected) {
+        const parsed = parseResp(buffer);
+        if (!parsed) break;
+        responses.push(parsed.value);
+        buffer = buffer.slice(parsed.offset);
+      }
+      if (responses.length >= expected) {
+        cleanup();
+        socket.end();
+        resolve(responses);
+      }
+    });
+    socket.on("connect", () => {
+      socket.write(payload);
+    });
+  });
+}
+
+class RedisStore {
+  constructor(url) {
+    this.config = parseRedisUrl(url);
+    this.prefix = "rate:auth:";
+  }
+
+  async increment(key, windowMs) {
+    const script =
+      "local current = redis.call('INCR', KEYS[1]);" +
+      "if current == 1 then redis.call('PEXPIRE', KEYS[1], ARGV[1]); end;" +
+      "local ttl = redis.call('PTTL', KEYS[1]); return {current, ttl}";
+    const namespacedKey = `${this.prefix}${key}`;
+    const commands = [];
+    const { username, password, db } = this.config;
+    if (password || username) {
+      if (username) commands.push(["AUTH", username, password || ""]);
+      else commands.push(["AUTH", password]);
+    }
+    if (db) commands.push(["SELECT", String(db)]);
+    commands.push(["EVAL", script, "1", namespacedKey, String(windowMs)]);
+
+    const responses = await sendRedisCommands(this.config, commands);
+    for (const res of responses) {
+      if (res instanceof Error) throw res;
+    }
+
+    const result = responses[responses.length - 1];
+    if (!Array.isArray(result) || result.length < 2) throw new Error("REDIS_INVALID_RESPONSE");
+    const count = Number(result[0]);
+    const ttl = Number(result[1]);
+    const ttlMs = Number.isFinite(ttl) && ttl > 0 ? ttl : windowMs;
+    return { count, resetAt: Date.now() + ttlMs };
+  }
+}
+
+class MemoryStore {
+  constructor() {
+    // WARNING: In-memory rate limiter; set REDIS_URL for shared enforcement.
+    this.store = new Map();
+  }
+
+  async increment(key, windowMs) {
+    const now = Date.now();
+    const entry = this.store.get(key);
+    if (!entry || entry.resetAt <= now) {
+      const resetAt = now + windowMs;
+      this.store.set(key, { count: 1, resetAt });
+      return { count: 1, resetAt };
+    }
+    entry.count += 1;
+    return { count: entry.count, resetAt: entry.resetAt };
+  }
+}
+
+const store = REDIS_URL ? new RedisStore(REDIS_URL) : new MemoryStore();
+
+function createLimiter({ keyPrefix, includeEmail }) {
+  return async (req, res, next) => {
+    try {
+      const key = `${keyPrefix}:${makeKey(req, includeEmail)}`;
+      const { count, resetAt } = await store.increment(key, RATE_LIMIT_WINDOW_MS);
+      const remaining = Math.max(0, RATE_LIMIT_MAX - count);
+      res.set("X-RateLimit-Limit", String(RATE_LIMIT_MAX));
+      res.set("X-RateLimit-Remaining", String(remaining));
+      res.set("X-RateLimit-Reset", String(Math.ceil(resetAt / 1000)));
+
+      if (count > RATE_LIMIT_MAX) {
+        const retryAfter = Math.max(0, Math.ceil((resetAt - Date.now()) / 1000));
+        res.set("Retry-After", String(retryAfter));
+        return res.status(429).json({
+          ok: false,
+          error: {
+            code: "RATE_LIMITED",
+            message: "Too many requests",
+            requestId: req.requestId,
+          },
+        });
+      }
+      return next();
+    } catch (err) {
+      logger.warn(
+        { requestId: req.requestId, err: { name: err?.name, message: err?.message } },
+        "Rate limiter error",
+      );
+      return next();
+    }
+  };
+}
+
+export const authRegisterLimiter = createLimiter({ keyPrefix: "register", includeEmail: false });
+export const authLoginLimiter = createLimiter({ keyPrefix: "login", includeEmail: true });
+export const authForgotPasswordLimiter = createLimiter({ keyPrefix: "forgot", includeEmail: true });
diff --git a/src/models/RefreshSession.js b/src/models/RefreshSession.js
new file mode 100644
--- /dev/null
+++ b/src/models/RefreshSession.js
@@ -0,0 +1,26 @@
+import mongoose from "mongoose";
+import { baseToJSON, getOrCreateModel } from "./_helpers.js";
+
+const { Schema } = mongoose;
+
+const RefreshSessionSchema = new Schema(
+  {
+    userId: { type: Schema.Types.ObjectId, ref: "User", required: true, index: true },
+    tokenHash: { type: String, required: true, unique: true, minlength: 64, maxlength: 64 },
+    createdAt: { type: Date, default: Date.now },
+    expiresAt: { type: Date, required: true, index: true },
+    rotatedAt: { type: Date, default: null },
+    revokedAt: { type: Date, default: null },
+    ip: { type: String, trim: true, maxlength: 64, default: null },
+    userAgent: { type: String, trim: true, maxlength: 200, default: null },
+  },
+  { timestamps: false, strict: true },
+);
+
+RefreshSessionSchema.index({ tokenHash: 1 }, { unique: true });
+RefreshSessionSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
+
+baseToJSON(RefreshSessionSchema);
+
+export const RefreshSession = getOrCreateModel("RefreshSession", RefreshSessionSchema);
+export default RefreshSession;
diff --git a/src/models/PasswordResetToken.js b/src/models/PasswordResetToken.js
new file mode 100644
--- /dev/null
+++ b/src/models/PasswordResetToken.js
@@ -0,0 +1,25 @@
+import mongoose from "mongoose";
+import { baseToJSON, getOrCreateModel } from "./_helpers.js";
+
+const { Schema } = mongoose;
+
+const PasswordResetTokenSchema = new Schema(
+  {
+    userId: { type: Schema.Types.ObjectId, ref: "User", required: true, index: true },
+    tokenHash: { type: String, required: true, unique: true, minlength: 64, maxlength: 64 },
+    createdAt: { type: Date, default: Date.now },
+    expiresAt: { type: Date, required: true, index: true },
+    usedAt: { type: Date, default: null },
+    ip: { type: String, trim: true, maxlength: 64, default: null },
+    userAgent: { type: String, trim: true, maxlength: 200, default: null },
+  },
+  { timestamps: false, strict: true },
+);
+
+PasswordResetTokenSchema.index({ tokenHash: 1 }, { unique: true });
+PasswordResetTokenSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });
+
+baseToJSON(PasswordResetTokenSchema);
+
+export const PasswordResetToken = getOrCreateModel("PasswordResetToken", PasswordResetTokenSchema);
+export default PasswordResetToken;
diff --git a/src/utils/authTokens.js b/src/utils/authTokens.js
new file mode 100644
--- /dev/null
+++ b/src/utils/authTokens.js
@@ -0,0 +1,158 @@
+import crypto from "node:crypto";
+import jwt from "jsonwebtoken";
+import { ENV } from "./env.js";
+
+export const REFRESH_COOKIE_NAME = "refreshToken";
+
+const ACCESS_TOKEN_TTL = process.env.JWT_ACCESS_TTL || ENV.ACCESS_TOKEN_TTL || "15m";
+const REFRESH_TOKEN_TTL = process.env.JWT_REFRESH_TTL || "30d";
+const PASSWORD_RESET_TTL = process.env.PASSWORD_RESET_TTL || "30m";
+
+const DURATION_RE = /^(\d+)\s*(ms|s|m|h|d)?$/i;
+
+function parseDurationMs(value, fallbackMs) {
+  if (value === undefined || value === null || value === "") return fallbackMs;
+  if (typeof value === "number" && Number.isFinite(value)) return Math.max(1, value);
+  const str = String(value).trim();
+  const match = DURATION_RE.exec(str);
+  if (!match) return fallbackMs;
+  const count = Number(match[1]);
+  const unit = (match[2] || "s").toLowerCase();
+  const multipliers = { ms: 1, s: 1000, m: 60_000, h: 3_600_000, d: 86_400_000 };
+  const mult = multipliers[unit] || 1000;
+  return Math.max(1, count * mult);
+}
+
+function parseBool(value, fallback) {
+  if (value === undefined || value === null || value === "") return fallback;
+  if (typeof value === "boolean") return value;
+  const s = String(value).trim().toLowerCase();
+  if (["1", "true", "yes", "y", "on"].includes(s)) return true;
+  if (["0", "false", "no", "n", "off"].includes(s)) return false;
+  return fallback;
+}
+
+function normalizeSameSite(value) {
+  const s = String(value || "lax").trim().toLowerCase();
+  if (s === "none" || s === "strict" || s === "lax") return s;
+  return "lax";
+}
+
+function parseCookieHeader(header) {
+  const out = {};
+  if (!header || typeof header !== "string") return out;
+  const parts = header.split(";");
+  for (const part of parts) {
+    const idx = part.indexOf("=");
+    if (idx === -1) continue;
+    const name = part.slice(0, idx).trim();
+    if (!name) continue;
+    const value = part.slice(idx + 1).trim();
+    try {
+      out[name] = decodeURIComponent(value);
+    } catch {
+      out[name] = value;
+    }
+  }
+  return out;
+}
+
+export function getJwtSecrets() {
+  const current = process.env.JWT_SECRET_CURRENT || ENV.JWT_SECRET;
+  const previous = process.env.JWT_SECRET_PREVIOUS;
+  const secrets = [];
+  if (current) secrets.push(current);
+  if (previous && previous !== current) secrets.push(previous);
+  return secrets;
+}
+
+export function signAccessToken({ userId, roles, emailLower, tokenVersion }) {
+  const [secret] = getJwtSecrets();
+  const tv = Number(tokenVersion || 0);
+  const payload = {
+    roles: Array.isArray(roles) ? roles : ["user"],
+    email: emailLower,
+    tokenVersion: tv,
+    tv,
+    jti: crypto.randomUUID(),
+  };
+
+  return jwt.sign(payload, secret, {
+    subject: String(userId),
+    issuer: ENV.JWT_ISSUER,
+    audience: ENV.JWT_AUDIENCE,
+    expiresIn: ACCESS_TOKEN_TTL,
+    algorithm: "HS256",
+  });
+}
+
+export function verifyAccessToken(token) {
+  const secrets = getJwtSecrets();
+  let lastErr;
+  for (const secret of secrets) {
+    try {
+      return jwt.verify(token, secret, {
+        issuer: ENV.JWT_ISSUER,
+        audience: ENV.JWT_AUDIENCE,
+        algorithms: ["HS256"],
+      });
+    } catch (err) {
+      lastErr = err;
+    }
+  }
+  throw lastErr || new Error("AUTH_INVALID");
+}
+
+export function getRefreshTokenTtlMs() {
+  return parseDurationMs(REFRESH_TOKEN_TTL, 30 * 24 * 60 * 60_000);
+}
+
+export function getPasswordResetTtlMs() {
+  return parseDurationMs(PASSWORD_RESET_TTL, 30 * 60_000);
+}
+
+export function generateToken() {
+  return crypto.randomBytes(32).toString("hex");
+}
+
+export function hashToken(raw) {
+  return crypto.createHash("sha256").update(String(raw)).digest("hex");
+}
+
+export function safeEqual(a, b) {
+  const ab = Buffer.from(String(a));
+  const bb = Buffer.from(String(b));
+  if (ab.length !== bb.length) return false;
+  return crypto.timingSafeEqual(ab, bb);
+}
+
+export function getRefreshCookieOptions(maxAgeMs) {
+  const secureDefault = ENV.NODE_ENV === "production";
+  const secure = parseBool(process.env.COOKIE_SECURE, secureDefault);
+  const sameSite = normalizeSameSite(process.env.COOKIE_SAMESITE);
+  const domain = process.env.COOKIE_DOMAIN ? String(process.env.COOKIE_DOMAIN) : undefined;
+  const opts = {
+    httpOnly: true,
+    secure,
+    sameSite,
+    path: "/",
+  };
+  if (domain) opts.domain = domain;
+  if (Number.isFinite(maxAgeMs)) opts.maxAge = Math.max(1, Math.floor(maxAgeMs));
+  return opts;
+}
+
+export function getRefreshTokenFromReq(req) {
+  const cookies = parseCookieHeader(req?.headers?.cookie);
+  return cookies[REFRESH_COOKIE_NAME] || null;
+}
+
+export function setRefreshCookie(res, token, maxAgeMs) {
+  const opts = getRefreshCookieOptions(maxAgeMs);
+  res.cookie(REFRESH_COOKIE_NAME, token, opts);
+}
+
+export function clearRefreshCookie(res) {
+  const opts = getRefreshCookieOptions();
+  res.clearCookie(REFRESH_COOKIE_NAME, opts);
+}
diff --git a/src/utils/authSchemas.js b/src/utils/authSchemas.js
new file mode 100644
--- /dev/null
+++ b/src/utils/authSchemas.js
@@ -0,0 +1,93 @@
+import { z } from "zod";
+
+const COMMON_PASSWORDS = new Set([
+  "password",
+  "123456",
+  "12345678",
+  "123456789",
+  "1234567890",
+  "qwerty",
+  "qwerty123",
+  "111111",
+  "000000",
+  "password1",
+  "iloveyou",
+  "admin",
+  "letmein",
+  "welcome",
+  "abc123",
+  "monkey",
+  "dragon",
+  "sunshine",
+  "football",
+  "princess",
+]);
+
+function isCommonPassword(value) {
+  return COMMON_PASSWORDS.has(String(value || "").trim().toLowerCase());
+}
+
+const emailSchema = z.string().trim().email().max(254);
+
+const passwordSchema = z
+  .string()
+  .min(12, "Password must be at least 12 characters")
+  .max(200)
+  .refine((val) => !isCommonPassword(val), { message: "Password is too common" });
+
+const emptyBodySchema = z.object({}).strict().default({});
+
+function wrapBody(schema) {
+  return z
+    .object({
+      body: schema,
+      query: z.any().optional(),
+      params: z.any().optional(),
+      headers: z.any().optional(),
+    })
+    .strict();
+}
+
+const registerSchema = z
+  .object({
+    email: emailSchema,
+    password: passwordSchema,
+    phone: z.string().trim().max(30).optional(),
+  })
+  .strict()
+  .superRefine((val, ctx) => {
+    const email = String(val.email || "").toLowerCase();
+    const local = email.split("@")[0] || "";
+    const pwd = String(val.password || "").toLowerCase();
+    if (local.length >= 3 && pwd.includes(local)) {
+      ctx.addIssue({
+        code: z.ZodIssueCode.custom,
+        path: ["password"],
+        message: "Password should not contain your email",
+      });
+    }
+  });
+
+export const authSchemas = {
+  register: wrapBody(registerSchema),
+  login: wrapBody(
+    z
+      .object({
+        email: emailSchema,
+        password: z.string().min(1).max(200),
+      })
+      .strict(),
+  ),
+  refresh: wrapBody(emptyBodySchema),
+  logout: wrapBody(emptyBodySchema),
+  logoutAll: wrapBody(emptyBodySchema),
+  forgotPassword: wrapBody(z.object({ email: emailSchema }).strict()),
+  resetPassword: wrapBody(
+    z
+      .object({
+        token: z.string().trim().min(32).max(256),
+        password: passwordSchema,
+      })
+      .strict(),
+  ),
+};
diff --git a/src/services/mail.service.js b/src/services/mail.service.js
new file mode 100644
--- /dev/null
+++ b/src/services/mail.service.js
@@ -0,0 +1,10 @@
+import { logger } from "../utils/logger.js";
+
+export async function sendPasswordResetEmail({ to, token, requestId } = {}) {
+  if (!to || !token) {
+    return { sent: false, skipped: true, reason: "MISSING_PARAMS" };
+  }
+
+  logger.info({ to, requestId }, "Password reset email stub (not sent)");
+  return { sent: false, skipped: true, reason: "NOT_IMPLEMENTED" };
+}
